<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS interview 4</title>
</head>
<body>
    <h1><u>DAY-4</u></h1>
    <h2>How many operators do we have in JS ?</h2>
    We have 6 types of operators in JS they are
1. Arithmetic Operators : + - * / %
2. Comparison Operators : == === != !==
3. Logical Operators : && || !
4. Assignment Operators : =
5. Conditional Operators
6. Ternary Operator ?:
<hr>
<h2>What are pure functions?</h2>
Pure Function is a function (a block of code ) that always returns the same result if the same
arguments are passed. It does not depend on any state, or data change during a program’s
execution rather it only depends on its input arguments.
Let’s see the below JavaScript Function:
function calculateGST( productPrice ) {
return productPrice * 0.05;
}
The above function will always return the same result, if we pass the same productPrice. In
other words, it’s output doesn’t get effected by any other values / state changes. So we can call
“calculateGST” function as a Pure function.

<hr>
<h2>What is callback hell</h2>
Callback Hell is a pattern with multiple nested callbacks which makes code hard to read and
debug when dealing with asynchronous logic. The callback hell looks like a pyramid structure.
async1(function(){
async2(function(){
async3(function(){
async4(function(){
....
});
});
});
});
<hr>
<h2>What is promise chaining</h2>
he process of executing a sequence of asynchronous tasks one after another using promises is
known as Promise chaining. Let's take an example of promise chaining for calculating the final
result,
new Promise(function(resolve, reject) {
setTimeout(() => resolve(1), 1000);
}).then(function(result) {
console.log(result); // 1
return result * 2;
}).then(function(result) {
console.log(result); // 2
return result * 3;
}).then(function(result) {
console.log(result); // 6
return result * 4;
});
In the above handlers, the result is passed to the chain of .then() handlers with the below work
flow
1. The initial promise resolves in 1 second,
2. After that .then handler is called by logging the result(1) and then return a promise with
the value of result * 2.
3. After that the value passed to the next .then handler by logging the result(2) and return a
promise with result * 3.
4. Finally the value passed to the last .then handler by logging the result(6) and return a
promise with result * 4.
<hr>
<h2>What are arrow functions?</h2>
Arrow Functions — also called “fat arrow” functions, are relatively a new way of writing
concise functions in JavaScript. They have been introduced by the ECMAScript 6
specifications and since then become the most popular ES6 feature. Arrow functions allow us
to use the fat arrow => operator to quickly define JavaScript functions, with or without
parameters. We are able to omit the curly braces and the function and return keywords.
// function expression
let x = function(x, y) {
return x * y;
}
can be written as
// using arrow functions
let x = (x, y) => x * y;
<hr>
<h2>Give an example of async/await</h2>
function resolveAfter2Seconds()
return new Promise(resolve =>
{
setTimeout(() => {
resolve('resolved')
}, 2000);
});
}
async function asyncCall() {
console.log('calling');
const result = await resolveAfter2Seconds();
console.log(result);
// expected output: "resolved"
<hr>
<h2>What is a Temporal Dead Zone?</h2>
The Temporal Dead Zone is a behavior in JavaScript that occurs when declaring a variable
with the let and const keywords, but not with var. In ECMAScript 6, accessing a let or const
variable before its declaration (within its scope) causes a ReferenceError. The time span when
that happens, between the creation of a variable’s binding and its declaration, is called the
temporal dead zone.
Let's see this behavior with an example,
function somemethod() {
console.log(counter1); // undefined
console.log(counter2); // ReferenceError
var counter1 = 1;
let counter2 = 2;
}
<hr>

</body>
</html>