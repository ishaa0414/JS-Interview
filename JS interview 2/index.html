<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS interview</title>
</head>
<body>
    <h1><u>DAY-2</u></h1>
    <h2>What is creation phase and execution phase?</h2>
    Compiler runs through the entire code for 2 time before actually executing the code, and
generates a Global Execution context , inside this we have two phases creation phase and
execution phase.Creation Phase
1. In the first run, It picks all function declarations and stores them in memory with
their reference.
2. In the second run, It picks all variables and assign undefined to them. In the event of
a conflict between variable and function declaration name then that variable is
ignored.
Execution Phase
1. Variables assigned with values given in code at the time of initialization.
2. Functions executed
<hr>
<h2>What are objects in javascript?</h2>
In JavaScript, an object is an unordered collection of key-value pairs. Each key-value pair is
called a property.
The key of a property can be a string. And the value of a property can be any value, e.g., a
string, a number, an array, and even a function.
JavaScript provides you with many ways to create an object. The most commonly used one is
to use the object literal notation.
The following example creates an empty object using the object literal notation:
let empty = {};
<hr>
<h2>What are function constructors?</h2>
The Function() constructor creates a new Function object. Calling the constructor directly can create functions dynamically, but suffers from security and similar (but far less significant) performance issues as eval(). However, unlike eval (which may have access to the local scope), the Function constructor creates functions which execute in the global scope only.
<hr>
<h2>Explain prototypes</h2>
Prototypes are the mechanism by which JavaScript objects inherit features from one another.
<hr>
<h2>What is prototype chain?</h2>
Prototype chaining is used to build new types of objects based on existing ones. It is similar to
inheritance in a class based language.
The prototype on object instance is available through Object.getPrototypeOf(object) or proto
property whereas prototype on constructors function is available through Object.prototype.
<hr>
<h2>Give an example of inheritance using function constructor</h2>
function Employee(name, age, gender, id) {
    this.name = name;
    this.age = age;
    this.gender = gender;
    this.id = id;
    };
    function Developer(name, age, gender, id, specialization) {
    // Calling Employee constructor function
    Employee.call(this, name, age, gender, id);
    // Adding a new parameter
    this.specialization = specialization;
    }
    // Creating objects
    let Employee1 = new Employee("Suraj", 28, "Male", 564);
    let Developer1 = new Developer("Karishma", 31, "Female", 345,
    "Frontend Developer");
    console.log(Employee1);
    console.log(Developer1);
    OUTPUT:<br>
    Employee { name: 'Suraj', age: 28, gender: 'Male', id: 564 }
Developer {
  name: 'Karishma',
  age: 31,
  gender: 'Female',
  id: 345,
  specialization: 'Frontend Developer'
}
    <hr>
    <h2>What are callbacks?</h2>
    A callback function is a function passed into another function as an argument. This function is
invoked inside the outer function to complete an action. Let's take a simple example of how to
use callback function
function callbackFunction(name) {
console.log('Hello ' + name);
}
function outerFunction(callback) {
let name = prompt('Please enter your name.');
callback(name);
}
outerFunction(callbackFunction);
<hr>

</body>
</html>